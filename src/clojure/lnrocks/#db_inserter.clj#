(ns lnrocks.db-inserter
  (:require [clojure.string :only [split split-lines trim]]
            [crux.api :as crux]
            [clojure.set :as s]
            [lnrocks.util :as util]
         ;;    [ln.db-manager :as dbm])
         ;;   [clojure.data.csv :as csv]
            [clojure.java.io :as io])
           )

;; \copy (Select * From assay_run) To '/home/mbc/projects/lnrocks/resources/data/assay-run.csv' With CSV

(defn easy-ingest
  "Uses Crux put transaction to add a vector of documents to a specified
  node"
  [node docs]
  (crux/submit-tx node
                  (vec (for [doc docs]
                         [:crux.tx/put doc]))))



(defn new-project
  [ node name description session-id]
  (let [ prj-id (:start (dbr/counter node :project 1))
        doc  {:crux.db/id (keyword (str "prj" prj-id))
              :ln-entity "project"
                :prj-name name
                :description description
                :session session-id}]
    (crux/submit-tx node [[:crux.tx/put doc]] )
  prj-id))

(defn new-plate
  ;;with-samples: boolean
  [ node project-id plate-set-id plate-id plate-format-id plate-type-id plate-layout-name-id with-samples sample-id-start unk-per-plate-needed]
  (let [wells (case plate-format-id
                96 util/map96wells
                384 util/map384wells
                1536 util/map1536wells)
        plt-doc { ;; :crux.db/id (keyword (str "plt-" plate-id))
                 :ln-entity "plate"
                 :plate-format-id plate-format-id
                 :plate-type-id plate-type-id
                 :project-id project-id
                 :id plate-id
                 :plate-sys-name (str "PLT-" plate-id)
                 :wells (if with-samples (util/fill-wells wells sample-id-start unk-per-plate-needed) wells)}]
    plt-doc))

;;(new-plate 1 1 2 96  1 1 true 3 3)

(defn new-plate-set
  ;;with-samples: boolean
  [ node plate-set-name description num-plates plate-format-id plate-type-id
   project-id plate-layout-name-id lnsession-id with-samples] 
  (let [unk-per-plate-needed (:unknown-n (first (dbr/get-plate-layout node plate-layout-name-id)))
        start-ids (dbr/get-ps-plt-spl-ids node 1 num-plates (* num-plates unk-per-plate-needed) )
        ps-id (:plate-set start-ids)
        plate-start (:plate start-ids)
        plate-end (+ plate-start (- num-plates 1) )
        sample-start (:sample start-ids)
        spl-ids-start-vec (into [] (range sample-start (+ sample-start (* unk-per-plate-needed num-plates)) unk-per-plate-needed))
        ps-doc {:crux.db/id (keyword (str "PS-" ps-id))
                :ln-entity "plate-set"
                :ps-name plate-set-name
                :description description
                :num-plates num-plates
                :plate-format-id plate-format-id
                :plate-type-id plate-type-id
                :project-id project-id
                :plate-layout-name-id plate-layout-name-id
                :session lnsession-id
                :plates (loop [plate-id-counter plate-start
                               spl-vector-counter 0
                               plates []]
                          (if (> plate-id-counter plate-end)
                            plates
                            (recur (+ plate-id-counter 1)
                                   (+ spl-vector-counter 1)
                                   (conj plates (new-plate project-id ps-id plate-id-counter plate-format-id
                                                           plate-type-id plate-layout-name-id with-samples
                                                           (get spl-ids-start-vec spl-vector-counter) unk-per-plate-needed)))))}]
    (crux/submit-tx node [[:crux.tx/put ps-doc]])
    ps-id))





;; (defn import-barcode-ids [ plateset-id barcode-file]

;;    " Loads table and make the association
;;       barcodess looks like:

;;       plate 	barcode.id
;;       1     	AMRVK5473H
;;       1      	KMNCX9294W
;;       1      	EHRXZ2102Z
;;       1      	COZHR7852Q
;;       1      	FJVNR6433Q"
    
;;   (let [ col1name (first (util/get-col-names barcode-file))
;;         col2name (first (rest (util/get-col-names barcode-file)))
;;         table (util/table-to-map barcode-file)
;;         sql-statement (str "UPDATE plate SET barcode = ? WHERE plate.ID IN ( SELECT plate.id FROM plate_set, plate_plate_set, plate  WHERE plate_plate_set.plate_set_id=" (str plateset-id) " AND plate_plate_set.plate_id=plate.id AND plate_plate_set.plate_order=? )")
;;         content (into [] (zipmap (map #(:barcode.id %) table) (map #(Integer. (:plate %)) table)))
;;         ]
;;     (if (and (= col1name "plate")(= col2name "barcode.id"))
;;       (with-open [con (j/get-connection cm/conn)
;;                   ps  (j/prepare con [sql-statement])]
;;         (p/execute-batch! ps content))    
;;       (javax.swing.JOptionPane/showMessageDialog nil  (str "Expecting the headers \"plate\", and \"barcode.id\", but found\n" col1name  ", and " col2name  "."  )))))



